{"version":3,"file":"lib.modern.js","sources":["../src/version.ts","../src/components/MessageHandler.tsx","../src/components/LiveKitRoomWrapper.tsx","../src/ElevenLabsProvider.tsx","../src/utils/constants.ts","../src/hooks/useConversationCallbacks.ts","../src/hooks/useConversationSession.ts","../src/utils/tokenUtils.ts","../src/hooks/useLiveKitRoom.ts","../src/hooks/useMessageSending.ts","../src/utils/overrides.ts"],"sourcesContent":["// This file is auto-generated during build\nexport const PACKAGE_VERSION = \"0.5.1\";\n","import { useEffect } from \"react\";\nimport { useLocalParticipant, useDataChannel } from \"@livekit/react-native\";\nimport type { LocalParticipant } from \"livekit-client\";\nimport type {\n  Callbacks,\n  ClientToolsConfig,\n  ClientToolCallEvent,\n  ConversationEvent,\n} from \"../types\";\nimport React from \"react\";\n\ninterface MessageHandlerProps {\n  onReady: (participant: LocalParticipant) => void;\n  isConnected: boolean;\n  callbacks: Callbacks;\n  sendMessage: (message: unknown) => void;\n  clientTools?: ClientToolsConfig[\"clientTools\"];\n  updateCurrentEventId?: (eventId: number) => void;\n}\n\nexport function isValidEvent(event: unknown): event is ConversationEvent {\n  return typeof event === \"object\" && event !== null && \"type\" in event;\n}\n\nfunction extractMessageText(event: ConversationEvent): string | null {\n  switch (event.type) {\n    case \"user_transcript\":\n      return event.user_transcription_event.user_transcript;\n    case \"agent_response\":\n      return event.agent_response_event.agent_response;\n    default:\n      return null;\n  }\n}\n\nexport const MessageHandler = ({\n  onReady,\n  isConnected,\n  callbacks,\n  sendMessage,\n  clientTools = {},\n  updateCurrentEventId,\n}: MessageHandlerProps) => {\n  const { localParticipant } = useLocalParticipant();\n\n  // Track agent response count for synthetic event IDs (WebRTC mode)\n  const agentResponseCountRef = React.useRef(1);\n\n  useEffect(() => {\n    if (isConnected && localParticipant) {\n      onReady(localParticipant);\n    }\n  }, [isConnected, localParticipant, onReady]);\n\n  const handleClientToolCall = async (clientToolCall: ClientToolCallEvent) => {\n    if (clientToolCall.client_tool_call.tool_name in clientTools) {\n      try {\n        const result =\n          (await clientTools[clientToolCall.client_tool_call.tool_name](\n            clientToolCall.client_tool_call.parameters\n          )) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n        // The API expects result to be a string, so we need to convert it if it's not already a string\n        const formattedResult =\n          typeof result === \"object\" ? JSON.stringify(result) : String(result);\n\n        sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: clientToolCall.client_tool_call.tool_call_id,\n          result: formattedResult,\n          is_error: false,\n        });\n      } catch (e) {\n        const errorMessage = `Client tool execution failed with following error: ${(e as Error)?.message}`;\n        callbacks.onError?.(errorMessage, {\n          clientToolName: clientToolCall.client_tool_call.tool_name,\n        });\n        sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: clientToolCall.client_tool_call.tool_call_id,\n          result: `Client tool execution failed: ${(e as Error)?.message}`,\n          is_error: true,\n        });\n      }\n    } else {\n      if (callbacks.onUnhandledClientToolCall) {\n        callbacks.onUnhandledClientToolCall(clientToolCall.client_tool_call);\n        return;\n      }\n\n      const errorMessage = `Client tool with name ${clientToolCall.client_tool_call.tool_name} is not defined on client`;\n      callbacks.onError?.(errorMessage, {\n        clientToolName: clientToolCall.client_tool_call.tool_name,\n      });\n      sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: clientToolCall.client_tool_call.tool_call_id,\n        result: errorMessage,\n        is_error: true,\n      });\n    }\n  };\n\n  const _ = useDataChannel(msg => {\n    const decoder = new TextDecoder();\n    const message = JSON.parse(decoder.decode(msg.payload));\n\n    if (!isValidEvent(message)) {\n      callbacks.onDebug?.({\n        type: \"invalid_event\",\n        message,\n      });\n      return;\n    }\n\n    const messageText = extractMessageText(message);\n    if (messageText !== null) {\n      callbacks.onMessage?.({\n        message: messageText,\n        source: message.type === \"user_transcript\" ? \"user\" : \"ai\",\n      });\n    }\n\n    if (msg.from?.isAgent) {\n      callbacks.onModeChange?.({\n        mode: msg.from?.isSpeaking ? \"speaking\" : \"listening\",\n      });\n\n      // Track agent responses for feedback (WebRTC mode needs synthetic event IDs)\n      if (message.type === \"agent_response\" && updateCurrentEventId) {\n        const eventId = agentResponseCountRef.current++;\n        updateCurrentEventId(eventId);\n      }\n    }\n\n    switch (message.type) {\n      case \"ping\":\n        sendMessage({\n          type: \"pong\",\n          event_id: message.ping_event.event_id,\n        });\n        break;\n      case \"client_tool_call\":\n        handleClientToolCall(message);\n        break;\n      case \"audio\":\n        callbacks.onAudio?.(message.audio_event.audio_base_64);\n        break;\n      case \"vad_score\":\n        callbacks.onVadScore?.({\n          vadScore: message.vad_score_event.vad_score,\n        });\n        break;\n      case \"interruption\":\n        callbacks.onInterruption?.(message.interruption_event);\n        break;\n      case \"mcp_tool_call\":\n        callbacks.onMCPToolCall?.(message.mcp_tool_call);\n        break;\n      case \"mcp_connection_status\":\n        callbacks.onMCPConnectionStatus?.(message.mcp_connection_status);\n        break;\n      case \"agent_tool_response\":\n        callbacks.onAgentToolResponse?.(message.agent_tool_response);\n        break;\n      case \"conversation_initiation_metadata\":\n        callbacks.onConversationMetadata?.(\n          message.conversation_initiation_metadata_event\n        );\n        break;\n      case \"asr_initiation_metadata\":\n        callbacks.onAsrInitiationMetadata?.(\n          message.asr_initiation_metadata_event\n        );\n        break;\n      case \"agent_chat_response_part\":\n        callbacks.onAgentChatResponsePart?.(message.text_response_part);\n        break;\n      default:\n        callbacks.onDebug?.(message);\n        break;\n    }\n  });\n\n  return null;\n};\n","// @ts-nocheck - pnpm hoisting causes duplicate React type definitions\nimport React from 'react';\nimport { LiveKitRoom } from '@livekit/react-native';\nimport type { LocalParticipant } from 'livekit-client';\nimport type { Callbacks, ClientToolsConfig } from '../types';\nimport { MessageHandler } from './MessageHandler';\n\ninterface LiveKitRoomWrapperProps {\n  children: React.ReactNode;\n  serverUrl: string;\n  token: string;\n  connect: boolean;\n  onConnected: () => void;\n  onDisconnected: () => void;\n  onError: (error: Error) => void;\n  roomConnected: boolean;\n  callbacks: Callbacks;\n  onParticipantReady: (participant: LocalParticipant) => void;\n  sendMessage: (message: unknown) => void;\n  clientTools: ClientToolsConfig['clientTools'];\n  updateCurrentEventId?: (eventId: number) => void;\n}\n\nexport const LiveKitRoomWrapper = ({\n  children,\n  serverUrl,\n  token,\n  connect,\n  onConnected,\n  onDisconnected,\n  onError,\n  roomConnected,\n  callbacks,\n  onParticipantReady,\n  sendMessage,\n  clientTools,\n  updateCurrentEventId,\n}: LiveKitRoomWrapperProps) => {\n  return (\n    <LiveKitRoom\n      serverUrl={serverUrl}\n      token={token}\n      connect={connect}\n      audio={true}\n      video={false}\n      options={{\n        adaptiveStream: { pixelDensity: 'screen' },\n      }}\n      onConnected={onConnected}\n      onDisconnected={onDisconnected}\n      onError={onError}\n    >\n      <MessageHandler\n        onReady={onParticipantReady}\n        isConnected={roomConnected}\n        callbacks={callbacks}\n        sendMessage={sendMessage}\n        clientTools={clientTools}\n        updateCurrentEventId={updateCurrentEventId}\n      />\n      {children as any}\n    </LiveKitRoom>\n  );\n};","import React from 'react';\nimport { createContext, useContext, useState } from 'react';\nimport { registerGlobals } from '@livekit/react-native';\nimport type { LocalParticipant } from 'livekit-client';\nimport type { Callbacks, ConversationConfig, ConversationStatus, ClientToolsConfig } from './types';\nimport { constructOverrides } from './utils/overrides';\nimport { DEFAULT_SERVER_URL } from './utils/constants';\nimport { useConversationCallbacks } from './hooks/useConversationCallbacks';\nimport { useConversationSession } from './hooks/useConversationSession';\nimport { useLiveKitRoom } from './hooks/useLiveKitRoom';\nimport { useMessageSending } from './hooks/useMessageSending';\nimport { LiveKitRoomWrapper } from './components/LiveKitRoomWrapper';\n\ninterface ConversationOptions extends Callbacks, Partial<ClientToolsConfig> {\n  serverUrl?: string;\n  tokenFetchUrl?: string;\n}\n\nexport interface Conversation {\n  startSession: (config: ConversationConfig) => Promise<void>;\n  endSession: () => Promise<void>;\n  status: ConversationStatus;\n  isSpeaking: boolean;\n  // TODO: Implement setVolume when LiveKit React Native supports it\n  // setVolume: (volume: number) => void;\n  canSendFeedback: boolean;\n  getId: () => string;\n  sendFeedback: (like: boolean) => void;\n  sendContextualUpdate: (text: string) => void;\n  sendUserMessage: (text: string) => void;\n  sendUserActivity: () => void;\n  setMicMuted: (muted: boolean) => void;\n}\n\ninterface ElevenLabsContextType {\n  conversation: Conversation;\n  callbacksRef: { current: Callbacks };\n  serverUrl: string;\n  tokenFetchUrl?: string;\n  clientTools: ClientToolsConfig['clientTools'];\n  setCallbacks: (callbacks: Callbacks) => void;\n  setServerUrl: (url: string) => void;\n  setTokenFetchUrl: (url: string) => void;\n  setClientTools: (tools: ClientToolsConfig['clientTools']) => void;\n}\n\nconst ElevenLabsContext = createContext<ElevenLabsContextType | null>(null);\n\nexport const useConversation = (options: ConversationOptions = {}): Conversation => {\n  const context = useContext(ElevenLabsContext);\n  if (!context) {\n    throw new Error('useConversation must be used within ElevenLabsProvider');\n  }\n\n  const { serverUrl, tokenFetchUrl, clientTools, ...callbacks } = options;\n\n  React.useEffect(() => {\n    if (serverUrl) {\n      context.setServerUrl(serverUrl);\n    }\n  }, [context, serverUrl]);\n\n  React.useEffect(() => {\n    if (tokenFetchUrl) {\n      context.setTokenFetchUrl(tokenFetchUrl);\n    }\n  }, [context, tokenFetchUrl]);\n\n  if (clientTools) {\n    context.setClientTools(clientTools);\n  }\n\n  context.setCallbacks(callbacks);\n\n  return context.conversation;\n};\n\ninterface ElevenLabsProviderProps {\n  children: React.ReactNode;\n}\n\nexport const ElevenLabsProvider: React.FC<ElevenLabsProviderProps> = ({ children }) => {\n  // Initialize globals on mount\n  registerGlobals();\n\n  // State management\n  const [token, setToken] = useState('');\n  const [connect, setConnect] = useState(false);\n  const [status, setStatus] = useState<ConversationStatus>('disconnected');\n  const [serverUrl, setServerUrl] = useState(DEFAULT_SERVER_URL);\n  const [tokenFetchUrl, setTokenFetchUrl] = useState<string | undefined>(undefined);\n  const [conversationId, setConversationId] = useState<string>('');\n  const [isSpeaking, setIsSpeaking] = useState(false);\n  const [canSendFeedback, setCanSendFeedback] = useState(false);\n\n  // Feedback state tracking\n  const currentEventIdRef = React.useRef(1);\n  const lastFeedbackEventIdRef = React.useRef(1);\n\n  // Use ref for clientTools to avoid re-renders (like callbacks)\n  const clientToolsRef = React.useRef<ClientToolsConfig['clientTools']>({});\n\n  // Custom hooks\n  const { callbacksRef, setCallbacks: setCallbacksBase } = useConversationCallbacks();\n\n  // Enhanced setCallbacks that wraps onModeChange to update isSpeaking state\n  const setCallbacks = React.useCallback((callbacks: Callbacks) => {\n    const wrappedCallbacks = {\n      ...callbacks,\n      onModeChange: (event: { mode: 'speaking' | 'listening' }) => {\n        setIsSpeaking(event.mode === 'speaking');\n        callbacks.onModeChange?.(event);\n      }\n    };\n    setCallbacksBase(wrappedCallbacks);\n  }, [setCallbacksBase]);\n\n  const {\n    startSession,\n    endSession,\n    overrides,\n    customLlmExtraBody,\n    dynamicVariables,\n    userId,\n  } = useConversationSession(callbacksRef, setStatus, setConnect, setToken, setConversationId, tokenFetchUrl);\n\n  const {\n    roomConnected,\n    localParticipant,\n    handleParticipantReady,\n    handleConnected,\n    handleDisconnected,\n    handleError,\n  } = useLiveKitRoom(callbacksRef, setStatus, conversationId);\n\n  // Enhanced connection handler to initialize feedback state\n  const handleConnectedWithFeedback = React.useCallback(() => {\n    // Reset feedback state when connecting\n    currentEventIdRef.current = 1;\n    lastFeedbackEventIdRef.current = 1;\n    setCanSendFeedback(false);\n    callbacksRef.current.onCanSendFeedbackChange?.({ canSendFeedback: false });\n\n    handleConnected();\n  }, [handleConnected, callbacksRef]);\n\n  // Enhanced disconnection handler to reset feedback state\n  const handleDisconnectedWithFeedback = React.useCallback(() => {\n    setCanSendFeedback(false);\n    handleDisconnected();\n  }, [handleDisconnected]);\n\n  const { sendMessage } = useMessageSending(status, localParticipant, callbacksRef);\n\n  const updateCanSendFeedback = React.useCallback(() => {\n    const newCanSendFeedback = currentEventIdRef.current !== lastFeedbackEventIdRef.current;\n\n    if (canSendFeedback !== newCanSendFeedback) {\n      setCanSendFeedback(newCanSendFeedback);\n      callbacksRef.current.onCanSendFeedbackChange?.({ canSendFeedback: newCanSendFeedback });\n    }\n  }, [canSendFeedback, callbacksRef]);\n\n  const sendFeedback = React.useCallback((like: boolean) => {\n    if (!canSendFeedback) {\n      console.warn(\n        lastFeedbackEventIdRef.current === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    const feedbackMessage = {\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: currentEventIdRef.current,\n    };\n\n    sendMessage(feedbackMessage);\n    lastFeedbackEventIdRef.current = currentEventIdRef.current;\n    updateCanSendFeedback();\n  }, [canSendFeedback, sendMessage, updateCanSendFeedback]);\n\n  // setVolume placeholder (to be implemented when LiveKit supports it)\n  const setVolume = React.useCallback((volume: number) => {\n    console.warn('setVolume is not yet implemented in React Native SDK');\n  }, []);\n\n  const getId = () => conversationId;\n\n  const setMicMuted = React.useCallback((muted: boolean) => {\n    if (localParticipant) {\n      localParticipant.setMicrophoneEnabled(!muted);\n    }\n  }, [localParticipant]);\n\n  // Update current event ID for feedback tracking\n  const updateCurrentEventId = React.useCallback((eventId: number) => {\n    currentEventIdRef.current = eventId;\n    updateCanSendFeedback();\n  }, [updateCanSendFeedback]);\n\n  // Handle participant ready with overrides\n  const handleParticipantReadyWithOverrides = React.useCallback((participant: LocalParticipant) => {\n    handleParticipantReady(participant);\n\n    const overridesEvent = constructOverrides({\n      overrides,\n      customLlmExtraBody,\n      dynamicVariables,\n      userId,\n    });\n\n    if (overridesEvent) {\n      try {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(JSON.stringify(overridesEvent));\n        participant.publishData(data, { reliable: true });\n      } catch (error) {\n        console.error(\"Failed to send overrides:\", error);\n        callbacksRef.current.onError?.(error as string);\n      }\n    }\n  }, [handleParticipantReady, overrides, customLlmExtraBody, dynamicVariables, userId, callbacksRef]);\n\n  const conversation: Conversation = {\n    startSession,\n    endSession,\n    status,\n    isSpeaking,\n    // setVolume,\n    canSendFeedback,\n    getId,\n    setMicMuted,\n    sendFeedback,\n    sendContextualUpdate: (text: string) => {\n      sendMessage({\n        type: \"contextual_update\",\n        text,\n      });\n    },\n    sendUserMessage: (text: string) => {\n      sendMessage({\n        type: \"user_message\",\n        text,\n      });\n    },\n    sendUserActivity: () => {\n      sendMessage({\n        type: \"user_activity\",\n      });\n    },\n  };\n\n  // Create setClientTools function that only updates ref\n  const setClientTools = React.useCallback((tools: ClientToolsConfig['clientTools']) => {\n    clientToolsRef.current = tools;\n  }, []);\n\n  const contextValue: ElevenLabsContextType = {\n    conversation,\n    callbacksRef,\n    serverUrl,\n    tokenFetchUrl,\n    clientTools: clientToolsRef.current,\n    setCallbacks,\n    setServerUrl,\n    setTokenFetchUrl: setTokenFetchUrl,\n    setClientTools,\n  };\n\n  return (\n    <ElevenLabsContext.Provider value={contextValue}>\n      <LiveKitRoomWrapper\n        serverUrl={serverUrl}\n        token={token}\n        connect={connect}\n        onConnected={handleConnectedWithFeedback}\n        onDisconnected={handleDisconnectedWithFeedback}\n        onError={handleError}\n        roomConnected={roomConnected}\n        callbacks={callbacksRef.current}\n        onParticipantReady={handleParticipantReadyWithOverrides}\n        sendMessage={sendMessage}\n        clientTools={clientToolsRef.current}\n        updateCurrentEventId={updateCurrentEventId}\n      >\n        {children}\n      </LiveKitRoomWrapper>\n    </ElevenLabsContext.Provider>\n  );\n};","export const DEFAULT_SERVER_URL = \"wss://livekit.rtc.elevenlabs.io\";\n","import { useRef, useCallback } from \"react\";\nimport type { Callbacks } from \"../types\";\n\nexport const useConversationCallbacks = () => {\n  const callbacksRef = useRef<Callbacks>({});\n\n  const setCallbacks = useCallback((callbacks: Callbacks) => {\n    callbacksRef.current = callbacks;\n  }, []);\n\n  return {\n    callbacksRef,\n    setCallbacks,\n  };\n};\n","import { useState, useCallback } from \"react\";\nimport type {\n  ConversationConfig,\n  ConversationStatus,\n  Callbacks,\n} from \"../types\";\nimport {\n  getConversationToken,\n  extractConversationIdFromToken,\n} from \"../utils/tokenUtils\";\n\nexport const useConversationSession = (\n  callbacksRef: { current: Callbacks },\n  setStatus: (status: ConversationStatus) => void,\n  setConnect: (connect: boolean) => void,\n  setToken: (token: string) => void,\n  setConversationId: (conversationId: string) => void,\n  tokenFetchUrl?: string\n) => {\n  const [overrides, setOverrides] = useState<ConversationConfig[\"overrides\"]>(\n    {}\n  );\n  const [customLlmExtraBody, setCustomLlmExtraBody] =\n    useState<ConversationConfig[\"customLlmExtraBody\"]>(null);\n  const [dynamicVariables, setDynamicVariables] = useState<\n    ConversationConfig[\"dynamicVariables\"]\n  >({});\n  const [userId, setUserId] = useState<ConversationConfig[\"userId\"]>(undefined);\n\n  const startSession = useCallback(\n    async (config: ConversationConfig) => {\n      try {\n        setStatus(\"connecting\");\n        callbacksRef.current.onStatusChange?.({ status: \"connecting\" });\n\n        setOverrides(config.overrides || {});\n        setCustomLlmExtraBody(config.customLlmExtraBody || null);\n        setDynamicVariables(config.dynamicVariables || {});\n        setUserId(config.userId);\n\n        let conversationToken: string;\n\n        if (config.conversationToken) {\n          conversationToken = config.conversationToken;\n        } else if (config.agentId) {\n          console.info(\n            \"Getting conversation token for agentId:\",\n            config.agentId\n          );\n          // Use tokenFetchUrl from config first, then from hook parameter, then default\n          const urlToUse = config.tokenFetchUrl || tokenFetchUrl;\n          conversationToken = await getConversationToken(\n            config.agentId,\n            urlToUse\n          );\n        } else {\n          throw new Error(\"Either conversationToken or agentId is required\");\n        }\n\n        const extractedConversationId =\n          extractConversationIdFromToken(conversationToken);\n        setConversationId(extractedConversationId);\n\n        setToken(conversationToken);\n        setConnect(true);\n      } catch (error) {\n        setStatus(\"disconnected\");\n        callbacksRef.current.onStatusChange?.({ status: \"disconnected\" });\n        callbacksRef.current.onError?.(error as string);\n        throw error;\n      }\n    },\n    [\n      callbacksRef,\n      setStatus,\n      setConnect,\n      setToken,\n      setConversationId,\n      tokenFetchUrl,\n    ]\n  );\n\n  const endSession = useCallback(async () => {\n    try {\n      setConnect(false);\n      setToken(\"\");\n      setStatus(\"disconnected\");\n      callbacksRef.current.onStatusChange?.({ status: \"disconnected\" });\n      callbacksRef.current.onDisconnect?.({ reason: \"user\" });\n    } catch (error) {\n      callbacksRef.current.onError?.(error as string);\n      throw error;\n    }\n  }, [callbacksRef, setConnect, setToken, setStatus]);\n\n  return {\n    startSession,\n    endSession,\n    overrides,\n    customLlmExtraBody,\n    dynamicVariables,\n    userId,\n  };\n};\n","import { PACKAGE_VERSION } from \"../version\";\n\nexport const extractConversationIdFromToken = (token: string): string => {\n  try {\n    const tokenPayload = JSON.parse(atob(token.split(\".\")[1]));\n    const roomId = tokenPayload.video?.room || \"\";\n\n    return roomId.match(/(conv_[a-zA-Z0-9]+)/)?.[0] || \"\";\n  } catch (error) {\n    console.warn(\"Could not extract conversation ID from token\");\n    return \"\";\n  }\n};\n\nexport const getConversationToken = async (\n  agentId: string,\n  tokenFetchUrl?: string\n): Promise<string> => {\n  const baseUrl =\n    tokenFetchUrl || \"https://api.elevenlabs.io/v1/convai/conversation/token\";\n  const response = await fetch(\n    `${baseUrl}?agent_id=${agentId}&source=react_native_sdk&version=${PACKAGE_VERSION}`\n  );\n\n  const data = await response.json();\n\n  if (!response.ok) {\n    throw new Error(`Failed to get conversation token: ${data.detail.message}`);\n  }\n\n  if (!data.token) {\n    throw new Error(\"No conversation token received from API\");\n  }\n\n  return data.token;\n};\n","import { useState, useEffect, useCallback, useRef } from \"react\";\nimport { AudioSession } from \"@livekit/react-native\";\nimport type { LocalParticipant } from \"livekit-client\";\nimport type { ConversationStatus, Callbacks } from \"../types\";\n\nexport const useLiveKitRoom = (\n  callbacksRef: { current: Callbacks },\n  setStatus: (status: ConversationStatus) => void,\n  conversationId: string\n) => {\n  const [roomConnected, setRoomConnected] = useState(false);\n  const [localParticipant, setLocalParticipant] =\n    useState<LocalParticipant | null>(null);\n  const hasCalledOnConnectRef = useRef(false);\n\n  useEffect(() => {\n    const start = async () => {\n      await AudioSession.startAudioSession();\n    };\n\n    start();\n    return () => {\n      AudioSession.stopAudioSession();\n    };\n  }, []);\n\n  // Fire onConnect when both participant and room are fully ready\n  useEffect(() => {\n    if (localParticipant && roomConnected && !hasCalledOnConnectRef.current) {\n      hasCalledOnConnectRef.current = true;\n      callbacksRef.current.onConnect?.({ conversationId });\n    }\n  }, [localParticipant, roomConnected, conversationId, callbacksRef]);\n\n  const handleParticipantReady = useCallback(\n    (participant: LocalParticipant) => {\n      if (localParticipant) {\n        return;\n      }\n\n      setLocalParticipant(participant);\n      setStatus(\"connected\");\n    },\n    [localParticipant, setStatus]\n  );\n\n  const handleConnected = useCallback(() => {\n    setRoomConnected(true);\n  }, []);\n\n  const handleDisconnected = useCallback(() => {\n    setRoomConnected(false);\n    setStatus(\"disconnected\");\n    setLocalParticipant(null);\n    hasCalledOnConnectRef.current = false;\n    callbacksRef.current.onDisconnect?.({ reason: \"user\" });\n  }, [callbacksRef, setStatus]);\n\n  const handleError = useCallback(\n    (error: Error) => {\n      console.error(\"LiveKit error:\", error);\n      callbacksRef.current.onError?.(error.message, undefined);\n    },\n    [callbacksRef]\n  );\n\n  return {\n    roomConnected,\n    localParticipant,\n    handleParticipantReady,\n    handleConnected,\n    handleDisconnected,\n    handleError,\n  };\n};\n","import { useCallback } from \"react\";\nimport type { LocalParticipant } from \"livekit-client\";\nimport type { ConversationStatus, Callbacks } from \"../types\";\n\nexport const useMessageSending = (\n  status: ConversationStatus,\n  localParticipant: LocalParticipant | null,\n  callbacksRef: { current: Callbacks }\n) => {\n  const sendMessage = useCallback(\n    async (message: unknown) => {\n      if (status !== \"connected\" || !localParticipant) {\n        console.warn(\n          \"Cannot send message: room not connected or no local participant\"\n        );\n        return;\n      }\n      try {\n        const encoder = new TextEncoder();\n        const data = encoder.encode(JSON.stringify(message));\n\n        await localParticipant.publishData(data, { reliable: true });\n      } catch (error) {\n        console.error(\"Failed to send message via WebRTC:\", error);\n        console.error(\"Error details:\", error);\n        callbacksRef.current.onError?.(error as string);\n      }\n    },\n    [status, localParticipant, callbacksRef]\n  );\n\n  return { sendMessage };\n};\n","import type { ConversationConfig, InitiationClientDataEvent } from \"../types\";\nimport { PACKAGE_VERSION } from \"../version\";\n\nexport function constructOverrides(\n  config: ConversationConfig\n): InitiationClientDataEvent {\n  const overridesEvent: InitiationClientDataEvent = {\n    type: \"conversation_initiation_client_data\",\n  };\n\n  if (config.overrides) {\n    overridesEvent.conversation_config_override = {\n      agent: {\n        prompt: config.overrides.agent?.prompt,\n        first_message: config.overrides.agent?.firstMessage,\n        language: config.overrides.agent?.language,\n      },\n      tts: {\n        voice_id: config.overrides.tts?.voiceId,\n      },\n      conversation: {\n        text_only: config.overrides.conversation?.textOnly,\n      },\n    };\n  }\n\n  overridesEvent.source_info = {\n    source: \"react_native_sdk\",\n    version: config.overrides?.client?.version || PACKAGE_VERSION,\n  };\n\n  if (config.customLlmExtraBody) {\n    overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n  }\n\n  if (config.dynamicVariables) {\n    overridesEvent.dynamic_variables = config.dynamicVariables;\n  }\n\n  if (config.userId) {\n    overridesEvent.user_id = String(config.userId);\n  }\n\n  return overridesEvent;\n}\n"],"names":["PACKAGE_VERSION","MessageHandler","onReady","isConnected","callbacks","sendMessage","clientTools","updateCurrentEventId","localParticipant","useLocalParticipant","agentResponseCountRef","React","useRef","useEffect","useDataChannel","msg","_msg$from","decoder","TextDecoder","message","JSON","parse","decode","payload","event","onDebug","type","messageText","user_transcription_event","user_transcript","agent_response_event","agent_response","extractMessageText","_msg$from2","onMessage","source","from","isAgent","onModeChange","mode","isSpeaking","eventId","current","event_id","ping_event","async","clientToolCall","client_tool_call","tool_name","_await$_clientTools$c","result","parameters","formattedResult","stringify","String","tool_call_id","is_error","e","onError","clientToolName","onUnhandledClientToolCall","errorMessage","handleClientToolCall","onAudio","audio_event","audio_base_64","onVadScore","vadScore","vad_score_event","vad_score","onInterruption","interruption_event","onMCPToolCall","mcp_tool_call","onMCPConnectionStatus","mcp_connection_status","onAgentToolResponse","agent_tool_response","onConversationMetadata","conversation_initiation_metadata_event","onAsrInitiationMetadata","asr_initiation_metadata_event","onAgentChatResponsePart","text_response_part","LiveKitRoomWrapper","children","serverUrl","token","connect","onConnected","onDisconnected","roomConnected","onParticipantReady","createElement","LiveKitRoom","audio","video","options","adaptiveStream","pixelDensity","_excluded","ElevenLabsContext","createContext","useConversation","context","useContext","Error","tokenFetchUrl","_objectWithoutPropertiesLoose","setServerUrl","setTokenFetchUrl","setClientTools","setCallbacks","conversation","ElevenLabsProvider","registerGlobals","setToken","useState","setConnect","status","setStatus","undefined","conversationId","setConversationId","setIsSpeaking","canSendFeedback","setCanSendFeedback","currentEventIdRef","lastFeedbackEventIdRef","clientToolsRef","callbacksRef","setCallbacksBase","useConversationCallbacks","useCallback","wrappedCallbacks","_extends","startSession","endSession","overrides","customLlmExtraBody","dynamicVariables","userId","useConversationSession","setOverrides","setCustomLlmExtraBody","setDynamicVariables","setUserId","conversationToken","onStatusChange","config","agentId","console","info","urlToUse","baseUrl","response","fetch","data","json","ok","detail","getConversationToken","extractedConversationId","_tokenPayload$video","_roomId$match","atob","split","room","match","error","warn","extractConversationIdFromToken","onDisconnect","reason","handleParticipantReady","handleConnected","handleDisconnected","handleError","useLiveKitRoom","setRoomConnected","setLocalParticipant","hasCalledOnConnectRef","AudioSession","startAudioSession","start","stopAudioSession","onConnect","participant","handleConnectedWithFeedback","onCanSendFeedbackChange","handleDisconnectedWithFeedback","useMessageSending","TextEncoder","encode","publishData","reliable","updateCanSendFeedback","newCanSendFeedback","sendFeedback","like","score","volume","setMicMuted","muted","setMicrophoneEnabled","handleParticipantReadyWithOverrides","overridesEvent","_config$overrides","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","_config$overrides$con","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","text_only","textOnly","source_info","version","client","custom_llm_extra_body","dynamic_variables","user_id","constructOverrides","getId","sendContextualUpdate","text","sendUserMessage","sendUserActivity","tools","Provider","value"],"mappings":"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"}