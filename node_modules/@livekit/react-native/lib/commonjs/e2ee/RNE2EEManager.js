"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _reactNativeWebrtc = require("@livekit/react-native-webrtc");
var _livekitClient = require("livekit-client");
var _events = _interopRequireDefault(require("events"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * @experimental
 */
class RNE2EEManager extends _events.default {
  constructor(keyProvider, dcEncryptionEnabled = false) {
    super();
    _defineProperty(this, "room", void 0);
    _defineProperty(this, "frameCryptors", new Map());
    _defineProperty(this, "keyProvider", void 0);
    _defineProperty(this, "algorithm", _reactNativeWebrtc.RTCFrameCryptorAlgorithm.kAesGcm);
    _defineProperty(this, "encryptionEnabled", false);
    _defineProperty(this, "dataChannelEncryptionEnabled", false);
    _defineProperty(this, "dataPacketCryptorLock", new _livekitClient.Mutex());
    _defineProperty(this, "dataPacketCryptor", undefined);
    this.keyProvider = keyProvider;
    this.encryptionEnabled = false;
    this.dataChannelEncryptionEnabled = dcEncryptionEnabled;
  }
  get isEnabled() {
    return this.encryptionEnabled;
  }
  get isDataChannelEncryptionEnabled() {
    return this.isEnabled && this.dataChannelEncryptionEnabled;
  }
  set isDataChannelEncryptionEnabled(value) {
    this.dataChannelEncryptionEnabled = value;
  }
  setup(room) {
    if (this.room !== room) {
      this.room = room;
      this.setupEventListeners(room);
    }
  }
  setupEventListeners(room) {
    room.localParticipant.on(_livekitClient.ParticipantEvent.LocalTrackPublished, async publication => {
      this.setupE2EESender(publication, room.localParticipant);
    }).on(_livekitClient.ParticipantEvent.LocalTrackUnpublished, async publication => {
      let frameCryptor = this.findTrackCryptor(publication.trackSid);
      if (frameCryptor) {
        this.frameCryptors.delete(publication.trackSid);
        await frameCryptor.setEnabled(false);
        await frameCryptor.dispose();
      }
    });
    room.on(_livekitClient.RoomEvent.TrackSubscribed, (_track, pub, participant) => {
      this.setupE2EEReceiver(pub, participant);
    }).on(_livekitClient.RoomEvent.TrackUnsubscribed, async (_track, publication, _participant) => {
      let frameCryptor = this.findTrackCryptor(publication.trackSid);
      if (frameCryptor) {
        this.frameCryptors.delete(publication.trackSid);
        await frameCryptor.setEnabled(false);
        await frameCryptor.dispose();
      }
    }).on(_livekitClient.RoomEvent.SignalConnected, () => {
      if (!this.room) {
        throw new TypeError(`expected room to be present on signal connect`);
      }
      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);
    });
  }
  async setupE2EESender(publication, participant) {
    if (!publication.isEncrypted) {
      return;
    }
    var frameCryptor = this.findTrackCryptor(publication.trackSid);
    if (!frameCryptor) {
      frameCryptor = this.createFrameCryptorForSender(publication.track.sender, participant.identity);
      this.frameCryptors.set(publication.trackSid, frameCryptor);
      frameCryptor.setEnabled(true);
      frameCryptor.setKeyIndex(this.keyProvider.getLatestKeyIndex(participant.identity));
    }
  }
  async setupE2EEReceiver(publication, participant) {
    if (!publication.isEncrypted) {
      return;
    }
    var frameCryptor = this.findTrackCryptor(publication.trackSid);
    if (!frameCryptor) {
      frameCryptor = this.createFrameCryptorForReceiver(publication.track.receiver, participant.identity);
      this.frameCryptors.set(publication.trackSid, frameCryptor);
      frameCryptor.setEnabled(true);
      frameCryptor.setKeyIndex(this.keyProvider.getLatestKeyIndex(participant.identity));
    }
  }
  setSifTrailer(trailer) {
    this.keyProvider.setSifTrailer(trailer);
  }
  async getDataPacketCryptor() {
    let dataPacketCryptor = this.dataPacketCryptor;
    if (dataPacketCryptor) {
      return dataPacketCryptor;
    }
    let unlock = await this.dataPacketCryptorLock.lock();
    try {
      dataPacketCryptor = this.dataPacketCryptor;
      if (dataPacketCryptor) {
        return dataPacketCryptor;
      }
      dataPacketCryptor = await _reactNativeWebrtc.RTCDataPacketCryptorFactory.createDataPacketCryptor(this.algorithm, this.keyProvider.rtcKeyProvider);
      this.dataPacketCryptor = dataPacketCryptor;
      return dataPacketCryptor;
    } finally {
      unlock();
    }
  }
  async encryptData(data) {
    let room = this.room;
    if (!room) {
      throw new Error("e2eemanager isn't setup with room!");
    }
    let participantId = room.localParticipant.identity;
    let dataPacketCryptor = await this.getDataPacketCryptor();
    let encryptedPacket = await dataPacketCryptor.encrypt(participantId, this.keyProvider.getLatestKeyIndex(participantId), data);
    if (!encryptedPacket) {
      throw new Error('encryption for packet failed');
    }
    return {
      uuid: '',
      //not used
      payload: encryptedPacket.payload,
      iv: encryptedPacket.iv,
      keyIndex: encryptedPacket.keyIndex
    };
  }
  async handleEncryptedData(payload, iv, participantIdentity, keyIndex) {
    let packet = {
      payload,
      iv,
      keyIndex
    };
    let dataPacketCryptor = await this.getDataPacketCryptor();
    let decryptedData = await dataPacketCryptor.decrypt(participantIdentity, packet);
    if (!decryptedData) {
      throw new Error('decryption for packet failed');
    }
    return {
      uuid: '',
      //not used
      payload: decryptedData
    };
  }

  // Utility methods
  //////////////////////

  findTrackCryptor(trackId) {
    return this.frameCryptors.get(trackId);
  }
  createFrameCryptorForSender(sender, participantId) {
    return _reactNativeWebrtc.RTCFrameCryptorFactory.createFrameCryptorForRtpSender(participantId, sender, this.algorithm, this.keyProvider.rtcKeyProvider);
  }
  createFrameCryptorForReceiver(receiver, participantId) {
    return _reactNativeWebrtc.RTCFrameCryptorFactory.createFrameCryptorForRtpReceiver(participantId, receiver, this.algorithm, this.keyProvider.rtcKeyProvider);
  }
  setupEngine(_engine) {
    // No-op
  }
  setParticipantCryptorEnabled(enabled, participantIdentity) {
    var _this$room;
    if (this.encryptionEnabled !== enabled && participantIdentity === ((_this$room = this.room) === null || _this$room === void 0 ? void 0 : _this$room.localParticipant.identity)) {
      this.encryptionEnabled = enabled;
      this.emit(_livekitClient.EncryptionEvent.ParticipantEncryptionStatusChanged, enabled, this.room.localParticipant);
    } else {
      var _this$room2;
      const participant = (_this$room2 = this.room) === null || _this$room2 === void 0 ? void 0 : _this$room2.getParticipantByIdentity(participantIdentity);
      if (!participant) {
        throw TypeError(`couldn't set encryption status, participant not found ${participantIdentity}`);
      }
      this.emit(_livekitClient.EncryptionEvent.ParticipantEncryptionStatusChanged, enabled, participant);
    }
  }
}
exports.default = RNE2EEManager;
//# sourceMappingURL=RNE2EEManager.js.map